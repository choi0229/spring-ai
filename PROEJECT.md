# 프로젝트 과제: 장바구니 기반 멀티 레벨 포인트 적립 시스템

> **전제**  
> 기존 코드나 스키마가 전혀 없는 상태에서 시작한다고 가정한다. 아래 요구 사항을 모두 만족하는 Spring Boot(또는 동등한 서버 애플리케이션)를 설계·구현해야 한다.

## 1. 도메인 개요
- **사용자(User)**: 기본 정보와 포인트 잔액을 보유한다.
- **장바구니(Cart)**: 인메모리 혹은 캐시 기반으로 유지되는 세션성 데이터. 품목, 수량, 예상 적립 포인트를 확인할 수 있어야 한다.
- **주문/구매(Order/Purchase)**: 장바구니를 주문으로 확정할 때 생성된다. 결제 금액, 적립 포인트, 사용 포인트, 상태(PENDING/COMPLETED/CANCELED 등)를 포함한다.
- **포인트 지갑(PointWallet)**: 적립·차감·소멸 트랜잭션을 기록하며 현재 잔액을 계산한다.
- **환불(Refund)**: 주문 취소 혹은 환불 시 포인트와 재고를 되돌리는 절차를 수행한다.

## 2. 기능 요구 사항
1. **사용자 관리**
   - **1.1 필수 구현**  
     - 사용자 CRUD API 제공, 이메일 중복 검증 및 삭제 시 포인트 지갑 상태와 일관성 유지.  
       → 사용자를 관리하는 기본 REST 엔드포인트를 만들고 `ApiResponse` 포맷으로 응답해야 한다는 뜻이다.
   - **1.2 Advanced (실습 심화)**  
     - AOP 기반 감사 로그: `@Loggable` 또는 공통 포인트컷을 이용해 사용자 생성/수정 요청을 로깅한다.  
     - 사용자 통계 캐싱: 최근 주문/포인트 합계를 계산한 뒤 간단한 캐시(Map 또는 Caffeine)로 일정 시간 재사용한다.
   - **1.3 필수 테스트 케이스**  
     - 이메일 중복 가입 시 `ServiceException` 이 발생하는 단위 테스트.  
     - 삭제 API 호출 후 지갑 `active` 플래그가 false 로 바뀌는지 MockMvc 테스트.

2. **장바구니 서비스**
   - **2.1 필수 구현**  
     - 항목 추가/삭제/조회 API를 제공하고, 현재 총액과 예상 적립 포인트를 반환한다.  
       → `CartService` 가 사용자/상품 저장소와 연동하여 장바구니 요약 DTO 를 만들어야 한다.
   - **2.2 Advanced (실습 심화)**  
     - 저장소 추상화: 인메모리 외에 Redis 등으로 교체할 수 있도록 `CartStorage` 인터페이스를 둔다.  
     - 쿠폰/프로모션 배수 적용: 장바구니에 간단한 쿠폰 코드를 적용하면 예상 포인트가 배수로 늘어나도록 한다.
   - **2.3 필수 테스트 케이스**  
     - 카테고리별 가중치가 반영된 예상 포인트 계산 단위 테스트.  
     - 최대 품목 수 초과 시 400 응답이 내려오는 MockMvc 테스트.

3. **포인트 계정 및 적립 규칙**
   - **3.1 필수 구현**  
     - `PointWallet`, `PointTransaction` 엔티티와 Flyway 마이그레이션, 잔액/거래 기록, 만료 정책을 구성한다.  
       → 포인트 적립/사용 시 항상 트랜잭션 엔티티가 생성되어야 한다.
   - **3.2 Advanced (실습 심화)**  
     - 이벤트 발행: 포인트 적립/차감 시 내부용 이벤트 퍼블리셔(로그 기반)로 기록한다.  
     - 만료 스케줄러 대신 수동 API: 실습 범위 내에서 만료 처리를 호출형 서비스로 구현하고 단위 테스트로 검증한다.
   - **3.3 필수 테스트 케이스**  
     - 포인트 차감 시 잔액 부족 예외 발생 테스트.  
     - 최소 사용 금액/포인트 조건을 위반하면 예외가 발생하는지 서비스 테스트.

4. **주문 생성 및 결제 플로우**
   - **4.1 필수 구현**  
     - 장바구니 요약 → 주문 생성 → 포인트 사용/적립을 하나의 트랜잭션으로 묶는다.  
       → 재고 차감, 포인트 차감/적립, 주문 저장이 모두 성공해야 커밋된다.
   - **4.2 Advanced (실습 심화)**  
     - Mock Payment 처리: 단순 성공/실패 시나리오를 주입 가능한 전략(인터페이스)으로 작성한다.  
     - 실행시간 AOP를 주문 서비스에 적용하여 느린 주문을 로깅한다.
   - **4.3 필수 테스트 케이스**  
     - 주문 성공 후 포인트 적립 트랜잭션이 생성되는 통합(API) 테스트.  
     - 두 번 연속 주문 시 포인트 잔액이 올바르게 감소하는 서비스 단위 테스트(락 없이 검증).

5. **환불 및 포인트 회수**
   - **5.1 필수 구현**  
     - 환불 승인 시 재고 복구 + 포인트 회수/복원을 처리하고 상태를 갱신한다.  
       → 환불 이유와 상태(`APPROVED`, `ON_HOLD`)를 응답 DTO에 포함한다.
   - **5.2 Advanced (실습 심화)**  
     - 감사 로그: 환불을 진행할 때마다 별도 로그 테이블/서비스에 기록한다.  
     - 부분 환불: 주문 항목별로 수량을 선택해 환불할 수 있도록 커맨드/로직을 작성한다.
   - **5.3 필수 테스트 케이스**  
     - 환불 성공 시 재고/포인트/주문 상태가 바뀌는 API 테스트.  
     - 환불 요청 수량이 잔여 수량보다 많을 때 예외가 발생하는 단위 테스트.

6. **리포트**
   - **6.1 필수 구현**  
     - QueryDSL 로 일별 포인트 적립/사용 합계를 조회하는 API.  
       → `/api/reports/points` 가 기간 필터를 받아 데이터를 반환한다.
   - **6.2 Advanced (실습 심화)**  
     - ReportService 를 Given-When-Then 스타일 테스트로 검증한다.  
     - 컨트롤러에 `@Loggable` 을 붙여 호출 로그를 남긴다.
   - **6.3 필수 테스트 케이스**  
     - 기간 파라미터가 없을 때 기본 기간으로 조회되는 API 테스트.  
     - QueryDSL 레이어가 올바른 DTO를 반환하는 단위 테스트.

7. **테스트 작성**
   - **7.1 필수 구현**  
     - AAA 방식 단위 테스트와 MockMvc 기반 API 테스트를 혼합해 작성한다.  
     - 서비스/컨트롤러 레이어 별로 최소 1개 이상의 테스트가 있어야 한다.
   - **7.2 Advanced (실습 심화)**  
     - Given-When-Then(GWT) 스타일 테스트를 선택된 서비스에 도입한다.  
     - Spring AOP 또는 슬라이스 테스트를 활용해 cross-cutting 로직을 검증한다.
   - **7.3 필수 테스트 케이스**  
     - 장바구니→주문→환불 전체 흐름을 따라가는 API 기반 시나리오 테스트.  
     - 설정값(적립률, 한도)을 변경했을 때 회귀 테스트가 실패하지 않는지 확인하는 단위 테스트.

## 3. 기술 요구 사항
- **Spring Boot 3.x / Java 17** 권장.
- **JPA + QueryDSL** 조합으로 데이터 접근 계층을 작성한다.
- **Flyway**로 스키마 버전 관리를 수행한다.
- **AOP**를 활용해 `@Loggable`과 같은 마커 애노테이션을 정의하고, 로깅/실행시간/메트릭 관점을 구현한다.
- **검증/예외 처리**: `@Valid`와 글로벌 예외 처리기(ControllerAdvice)를 통해 공통 에러 응답 포맷(`ApiResponse`)을 유지한다.
- **테스트**: AAA와 GWT 방식의 단위 테스트 + MockMvc/RestAssured를 통한 웹 계층 테스트를 혼합한다.

## 4. 세부 가이드
1. **설정 파일**
   - `monitoring.slow-threshold-ms`: AOP 실행시간 로거가 “느린 호출”을 경고하는 임계치(밀리초). `ExecutionTimeAspect` 같은 공통 로직에서 주입받아 사용한다.
   - `points.default-rate`: 기본 적립률(예: `0.01`). 장바구니 요약과 주문 완료 시 동일한 규칙으로 사용한다.
   - `points.category-rate-map`: 카테고리별 가중치(예: `electronics:0.015`, `book:0.02`). 장바구니 예상 포인트 계산 시 상품 카테고리에 따라 기본 적립률을 덮어쓴다.
   - `points.vip-rate`: VIP 등급 사용자 전용 적립률. 사용자 등급에 따라 `default-rate`보다 우선 적용된다.
   - `points.min-usage-amount`: 포인트 사용이 가능한 주문 최소 금액. 주문 요청 DTO 검증 및 서비스 로직에서 활용한다.
   - `points.min-usage-point`: 한 번에 사용할 수 있는 최소 포인트 단위(예: 100P). 포인트 차감 시 업계 규칙을 반영한다.
   - `points.expire-days`: 적립 포인트 만료까지의 일수. 수동 만료 API가 `createdAt + expireDays`를 기준으로 회수한다.
   - `points.max-balance`: 포인트 지갑의 상한선(선택). 초과 적립 시 예외 혹은 절삭 처리를 한다.
   - `cart.max-items`: 장바구니에 담을 수 있는 최대 품목 수. 서비스 레벨에서 검증하여 과도한 메모리 사용을 방지한다.
   - 설정 값은 `@ConfigurationProperties` 또는 `@Value`로 주입하고, JSR 303 (`@Validated`)으로 범위를 검증한다.
2. **DTO 구성**
   - 컨트롤러 DTO(요청/응답)와 서비스 DTO(Command/Result)를 분리하여 계층 간 의존성을 최소화한다.
   - DTO 간 변환은 `UserMapper`, `OrderMapper` 같은 Mapper 클래스로 수행한다(서비스·컨트롤러에서 직접 변환 금지).
3. **동시성 & 트랜잭션**
   - 포인트 적립/차감 시 비관적 락 또는 Optimistic Lock을 사용하여 중복 차감을 방지한다.
4. **테스트 시나리오 예시**
   - **장바구니 요약 일치**: 상품 3개를 장바구니에 담은 후 주문을 생성했을 때, 장바구니가 계산한 예상 포인트와 실제 적립 포인트가 동일한지 검증.
   - **카테고리별 가중치**: 서로 다른 카테고리 상품을 조합했을 때 카테고리별 적립률이 올바르게 적용되는지 단위 테스트.
   - **포인트 부족 주문**: 사용자가 보유 포인트보다 많은 양을 사용하려 하면 `ServiceException`이 발생하는지 확인.
   - **최소 사용 조건**: 주문 금액 또는 사용 포인트가 최소 조건에 미달할 때 검증 오류가 발생하는지 컨트롤러 테스트.
   - **동시 주문 시나리오**: 두 개의 주문 요청이 동시에 포인트를 사용하려 할 때, 하나는 성공하고 다른 하나는 잔액 부족으로 롤백되는지(비관적/낙관적 락 테스트).
  - **환불 후 회수**: 환불 성공 시 적립 포인트가 정확히 차감되고 재고가 복구되는지 API 테스트.
   - **환불 보류 상태**: 환불하려는 시점에 이미 포인트가 사용되어 부족한 경우 상태가 `ON_HOLD`로 전환되는지 검증.
  - **만료 API**: 만료 수동 API 호출 후 포인트가 감소하고 트랜잭션이 기록되는지 단위 테스트.
  - **리포트 API**: QueryDSL 리포트 API가 특정 기간 내 사용자의 적립/사용 합계를 정확히 반환하는지 슬라이스 테스트.
5. **문서화**
   - README 또는 API 명세(Swagger/RestDocs)로 주요 엔드포인트와 시나리오를 설명한다.

## 5. 평가 포인트
- 계층 구조 설계와 책임 분리가 명확한가?
- 설정 기반의 동적 포인트 정책이 올바르게 동작하는가?
- 포인트/주문/환불 간 트랜잭션 경계가 일관성 있게 유지되는가?
- AOP, QueryDSL, Flyway, Mock API, 테스트 코드 등 프로젝트의 모든 기능을 활용했는가?
- 예외 및 경계 케이스(동시성, 포인트 부족, 만료 소멸 등)를 충분히 다루었는가?

---  
이 요구 사항을 기반으로 전체 애플리케이션 설계, 구현, 테스트, 문서화를 완성하라.
